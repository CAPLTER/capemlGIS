#' @title Construct a KML spatial file and create metadata of type spatial
#' vector
#'
#' @description create_vector_kml writes a spatial data file of type KML and
#' generates corresponding metadata of EML entity of type spatialVector
#'
#' @details create_vector_kml creates a EML spatialVector object from a spatial
#' data object (shapefile, kml) that is read into the R environment or created
#' in the R environment.  The function reads the attributes and classes
#' contained within a supporting yaml file generated from the
#' capeml::write_attributes function - create_vector_kml will look for a file
#' in the working directory with a name of type spatialEntityName_attrs.yaml.
#' If present, the function reads attribute and factor metadata from supporting
#' yaml file(s) generated from the capeml::write_attributes() and
#' capeml::write_factors() functions - create_vector_shape will look for files
#' in the working directory with a name of type "entity name"_attrs.yaml (or
#' "entity name"_attrs.csv if an older project) for attribute metadata, and
#' "entity name"_factors.yaml (or "entity name"_factors.csv if an older
#' project) for factor metadata. Note that this functionality is predicated on
#' the existence of a file containing metadata about the attributes, that that
#' file is in the working directory, and that the file matches the name of the
#' spatial data entity precisely.
#'
#' @note create_vector_kml will look for a package number (packageNum) in
#' config.yaml; this parameter is not passed to the function and it must exist.
#' @note Because file name metadata is incorporated into the kml generated from
#'  the sf::st_write function, including the md5 hash of the object in the file
#'  name sensu other products generated by capeml* packages is not feasible for
#'  spatialVector objects.
#' @note All vector objects are transformed to epsg 4326 (WGS 1984)
#'
#' @param vector_name
#'  (character) The unquoted name of the spatial data object in the R
#'  environment.
#' @param description
#'  (character) Description of the vector resource.
#' @param geoDescription
#'  (character) A textual description of the geographic study area of the
#'  vector. This parameter allows the user to overwrite the
#'  geographicDesciption value provided in the project config.yaml.
#' @param projectNaming
#'  (logical) Logical indicating if the vector file (or parent directory if
#'  zipFiles == TRUE) should be renamed per the style used by the CAP LTER
#'  (default) with the project id + base file name + md5sum + file extension.
#'  The passed file or directory name will be used if this parameter is set to
#'  FALSE.
#' @param missing_value_code
#' (character) Quoted character(s) of a flag, in addition to NA or NaN, used to
#' indicate missing values within the data.
#'
#' @import EML
#' @importFrom sf st_transform st_write
#' @importFrom yaml yaml.load_file
#' @importFrom tools md5sum
#' @importFrom capeml read_attributes
#'
#' @return EML spatialVector object is returned. Additionally, the spatial data
#' entity is written to file as type kml.
#'
#' @examples
#' \dontrun{
#'
#' # Load spatial vector object, here reading an existing kml file but this
#' # could be by constructing a spatial object in R using any means.
#' msp_arthropod_locations <- sf::st_read("msp_arthropod_locations.kml")
#'
#' # The Name attribute of a kml file describes the points so be sure that this field is populated with meaninful data.
#' msp_arthropod_locations <- msp_arthropod_locations %>%
#'   mutate(Name = sampling_locations)
#'
#' write_attributes(msp_arthropod_locations)
#'
#' msp_arthropod_locations_desc <- "Geospatial file (KML) detailing the
#' locations of ground-dwelling arthropod sampling sites in the McDowell
#' Sonoran Preserve, Scottsdale, Arizona. Polygons reflect the bounding box
#' (minimum and maximum extents) of paired (boundary-interior) sampling
#' locations. Precise sampling locations are available upon request to the CAP
#' LTER Data Manager."
#'
#' msp_arthropod_locations_SV <- create_vector_kml(
#'   vector_name = msp_arthropod_locations,
#'   description = msp_arthropod_locations_desc
#' )
#'
#' # The resulting spatialVector entity can be added to a EML dataset
#' }
#'
#' @export

create_vector_kml <- function(
  vector_name,
  description,
  geoDescription,
  projectNaming = TRUE,
  missing_value_code = NULL
  ) {

  # required parameters -------------------------------------------------------

  # do not proceed if a description is not provided

  if (missing("description")) {

    stop("please provide a description for this vector")

  }

  # do not proceed if config.yaml is not present

  if (!file.exists("config.yaml")) {

    stop("could not locate config.yaml in ", getwd())

  }


  # stringify vector name -----------------------------------------------------

  vector_name_string <- deparse(substitute(vector_name))


  # project naming ------------------------------------------------------------

  if (projectNaming == TRUE) {

    packageNum <- yaml::yaml.load_file("config.yaml")$packageNum

    fname <- paste0(packageNum, "_", vector_name_string, ".kml")

  } else {

    fname <- paste0(vector_name_string, ".kml")

  }


  # ensure epsg4326 -----------------------------------------------------------

  vector_name <- sf::st_transform(vector_name, crs = 4326)


  # geographic coverage -------------------------------------------------------

  if (missing("geoDescription") | is.null(geoDescription)) {

    geoDescription <- yaml::yaml.load_file("config.yaml")$geographicCoverage$geographicDescription
    message("project-level geographic description used for spatial entity ", vector_name_string)

  }

  if (is.na(geoDescription) | is.null(geoDescription) | geoDescription == "") {

    geoDescription <- NULL
    stop("entity ", vector_name_string," does not have a geographic description")

  }

  spatialCoverage <- EML::set_coverage(
    geographicDescription = geoDescription,
    westBoundingCoordinate =  sf::st_bbox(vector_name)[["xmin"]],
    eastBoundingCoordinate =  sf::st_bbox(vector_name)[["xmax"]],
    northBoundingCoordinate = sf::st_bbox(vector_name)[["ymax"]],
    southBoundingCoordinate = sf::st_bbox(vector_name)[["ymin"]]
  )


  # write to kml ------------------------------------------------------------

  sf::st_write(
    obj = vector_name,
    dsn = fname,
    driver = "kml",
    delete_layer = TRUE,
    delete_dsn = TRUE
  )


  # attributes ---------------------------------------------------------------

  if (file.exists(paste0(vector_name_string, "_attrs.yaml")) | file.exists(paste0(vector_name_string, "_attrs.csv"))) {

    attributes <- capeml::read_attributes(
      entity_name = vector_name_string,
      missing_value_code = missing_value_code 
    )

  } else {

    warning("missing attributes file: ", paste0(vector_name_string, "_attrs.yaml"), " / ", paste0(layer, "_attrs.yaml"))

  }


  # set physical ----------------------------------------------------------------

  # distribution

  fileURL <- yaml::yaml.load_file("config.yaml")$baseURL

  fileDistribution <- EML::eml$distribution(
    EML::eml$online(url = paste0(fileURL, fname))
  )

  # data format

  fileDataFormat <- EML::eml$dataFormat(
    externallyDefinedFormat = EML::eml$externallyDefinedFormat(
      formatName = "Google Earth Keyhole Markup Language (KML)")
  )

  # file size

  fileSize <- EML::eml$size(unit = "byte")
  fileSize$size <- deparse(file.size(fname))

  # authentication

  fileAuthentication <- EML::eml$authentication(method = "MD5")
  fileAuthentication$authentication <- md5sum(fname)

  # construct physical

  spatialVectorPhysical <- EML::eml$physical(
    objectName = fname,
    authentication = fileAuthentication,
    size = fileSize,
    dataFormat = fileDataFormat,
    distribution = fileDistribution
  )


  # create spatialVector entity ---------------------------------------------

  newSV <- EML::eml$spatialVector(
    entityName = fname,
    entityDescription = description,
    physical = spatialVectorPhysical,
    coverage = spatialCoverage,
    attributeList = attributes,
    geometricObjectCount = nrow(vector_name),
    id = fname
  )


  # add geometry type -------------------------------------------------------

  sfGeometry <- attr(vector_name$geometry, "class")[[1]]

  if (grepl("polygon", sfGeometry, ignore.case = TRUE)) {

    objectGeometry <- "Polygon"

  } else if (grepl("point", sfGeometry, ignore.case = TRUE)) {

    objectGeometry <- "Point"

  } else if (grepl("linestring", sfGeometry, ignore.case = TRUE)) {

    objectGeometry <- "LineString"

  } else {

    stop(paste0("undetermined geometry: ", attr(vector_name$geometry, "class")[[1]]))

  }

  newSV$geometry <- objectGeometry


  # add spatial reference  --------------------------------------------------

  epsg4326 <- EML::eml$spatialReference(
    horizCoordSysName = "GCS_WGS_1984"
  )

  newSV$spatialReference <- epsg4326


  # closing message ---------------------------------------------------------

  message("spatialVector ", fname,  " created")


  # return ------------------------------------------------------------------

  return(newSV)

} # close create_vector_kml

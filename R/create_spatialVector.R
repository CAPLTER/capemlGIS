#' @title create_spatialVector
#'
#' @description create_spatialVector generates a EML entity of type
#'   spatialVector
#'
#' @details create_spatialVector creates a EML spatialVector object from a
#'   spatial data object (shapefile, kml) that is read into the R environment.
#'   The function reads the attributes and classes contained within a supporting
#'   csv file generated from the write_attributes function -
#'   create_spatialVector will look for a file in the working directory with a
#'   name of type spatialEntityName_attrs.csv. Because all attributes written to
#'   a kml (the output of create_spatialVector are of type character, factors
#'   are not considered in this workflow). Note that this functionality is
#'   predicated on the existence of a file containing metadata about the
#'   attributes, that that file is in the working directory, and that the file
#'   matches the name of the spatial data entity precisely. In addition to
#'   generating a EML entity of type spatialVector, create_spatialVector writes
#'   the spatial entity in the R environment to file as type kml. Unless
#'   projectNaming is set to false, the output file is renamed with the file
#'   with project id + base file name + file extension (kml in this case).
#'
#' @note create_dataTable will look for a package number (packageNum) in
#'  config.yaml; this parameter is not passed to the function and it must exist.
#' @note create_spatialVector currently accepts an argument for a base url path
#'   to which the new file name will be appended so as to be a web-resolvable
#'   file; the package defaults to a URL specific to the CAP LTER.
#' @note Because file name metadata is incorporated into the kml generated from
#'  the sf::st_write function, including the md5 hash of the object in the file
#'  name sensu other products generated by capeml* packages is not feasible for
#'  spatialVector objects.
#' @note All vector objects are transformed to epsg 4326 (WGS 1984)
#'
#' @param svname
#'  The unquoted name of the spatial data object in the R environment.
#' @param description
#'  (character) Description of the vector resource.
#' @param geoDescription
#'  (character) A textual description of the geographic study area of the
#'  vector. This parameter allows the user to overwrite the
#'  geographicDesciption value provided in the project config.yaml.
#' @param baseURL
#'  (character) The base path of the web-accessible location of the data file;
#'  the name of the resulting file will be passed to the base path to generate
#'  a web-resolvable file path. This parameter is required with the default set
#'  to the CAP LTER file path
#' @param projectNaming
#'  (logical) Logical indicating if the vector file (or parent directory if
#'  zipFiles == TRUE) should be renamed per the style used by the CAP LTER
#'  (default) with the project id + base file name + md5sum + file extension.
#'  The passed file or directory name will be used if this parameter is set to
#'  FALSE.
#'
#' @import EML
#' @import dplyr
#' @import sf
#' @importFrom yaml yaml.load_file
#' @importFrom readr read_csv
#'
#' @return EML spatialVector object is returned. Additionally, the spatial data
#'  entity is written to file as type kml, and renamed with the project id +
#'  base file name + file extension (kml in this case).
#'
#' @examples
#' \dontrun{
#'
#' # read the vector using the sf package
#' NAIP_grid_map <- read_sf(dsn = 'NAIP_GRID.kml')
#'
#' # assign Name to the column that is the site identifier (Name in this
#' example); strip irrelevant or un-populated columns and remove geometry to
#' write # attribute table
#' NAIP_grid_map <- NAIP_grid_map %>%
#'   select(Name) %>%
#'   st_drop_geometry()
#'
#' # write the attributes to a csv template and add metadata - this file will be
#' # read when the EML object is build
#' write_attributes(NAIP_grid_map)
#'
#' # reimport kml to write spatial vector object
#'
#' colsToKeep <- read_sf(dsn = "NAIP_GRID.kml") %>%
#'   discard(~all(is.na(.x))) %>%
#'   map_df(~.x) %>%
#'   colnames()
#'
#' NAIP_grid_map <- read_sf(dsn = "NAIP_GRID.kml") %>%
#'   dplyr::select(one_of(colsToKeep))
#'
#' NAIP_grid_map_desc <- "NAIP NDVI data are presented as a series of tiles each
#' representing a portion of the overall central Arizona coverage area. The
#' relative position of tiles to the entire coverage area is detailed in this
#' file as a kml as well as the files NAIP_GRID.png and NAIP_GRID.pdf included
#' with this data set. Tiles are identified with a 20-digit signature (format:
#' xxxxxxxxxx-xxxxxxxxxx)."
#'
#' NAIP_grid_map_SV <- create_spatialVector(svname = NAIP_grid_map,
#'                                          description = NAIP_grid_map_desc,
#'                                          projectNaming = FALSE)
#'
#' # The resulting spatialVector entity can be added to a EML dataset
#' dataset <- EML::eml$dataset(spatialVector = NAIP_grid_map_SV)
#' }
#'
#' @export

create_spatialVector <- function(
  svname,
  description,
  geoDescription,
  baseURL = "https://data.gios.asu.edu/datasets/cap/",
  projectNaming = TRUE) {

  # required parameters -----------------------------------------------------

  # do not proceed if a description is not provided
  if (missing("description")) {

    stop("please provide a description for this vector")

  }


  # object names ------------------------------------------------------------

  # add kml extension and project id to object name if projectNaming == TRUE
  namestr <- deparse(substitute(svname))

  if (projectNaming == TRUE) {

    # if using project naming, add project-name specific elements to
    # spatialRaster entity

    # retrieve package number from config.yaml
    if (!file.exists("config.yaml")) {

      stop("config.yaml not found")

    }

    packageNum <- yaml::yaml.load_file("config.yaml")$packageNum

    fname <- paste0(packageNum, "_", namestr, ".kml")

  } else {

    fname <- paste0(namestr, ".kml")

  }


  # ensure epsg4326 ---------------------------------------------------------
  svname <- st_transform(svname, crs = 4326)


  # geographic coverage -----------------------------------------------------

  if (missing("geoDescription")) {

    # retrieve geographic description from config.yaml
    if (!file.exists("config.yaml")) {

      stop("could not locate geographic description, config.yaml not found")

    }

    geoDesc <- yaml::yaml.load_file("config.yaml")$geographicCoverage$geographicDescription

    if (is.na(geoDesc) | is.null(geoDesc) | geoDesc == "") {

      warning("geographic description provided in config.yaml is empty")

    }

  } else {

    geoDesc <- geoDescription

  }

  spatialCoverage <- EML::set_coverage(
    geographicDescription = geoDesc,
    west = st_bbox(svname)[['xmin']],
    east = st_bbox(svname)[['xmax']],
    north = st_bbox(svname)[['ymax']],
    south = st_bbox(svname)[['ymin']]
  )


  # write to kml ------------------------------------------------------------

  sf::st_write(
    obj = svname,
    dsn = fname,
    driver = "kml",
    delete_layer = TRUE,
    delete_dsn = TRUE)


  # attributes --------------------------------------------------------------

  # read the attributes file and extract classes into its own vector then delete
  # from attrs data frame (as required by rEML), but note that column classes
  # must be of type 'ordered', 'numeric', 'character', 'factor' or 'Date' so
  # change spatial types to character
  attrs <- read_csv(paste0(namestr, "_attrs.csv")) %>%
    mutate(
      columnClasses = replace(columnClasses, grepl("polygon", columnClasses, ignore.case = T), "character")
    )
  classes <- attrs %>% pull(columnClasses) # column classes to vector (req'd by set_attributes)
  attrs <- attrs %>% dplyr::select(-columnClasses) # remove col classes from attrs (req'd by set_attributes)
  attr_list <- set_attributes(attributes = attrs, col_classes = classes)


  # set physical ------------------------------------------------------------

  # distribution
  fileDistribution <- EML::eml$distribution(
    EML::eml$online(url = paste0(baseURL, fname))
  )

  # data format
  fileDataFormat <- EML::eml$dataFormat(
    externallyDefinedFormat = EML::eml$externallyDefinedFormat(
      formatName = "application/vnd.google-earth.kml+xml")
  )

  # file size
  fileSize <- EML::eml$size(unit = "byte")
  fileSize$size <- deparse(file.size(fname))

  # authentication
  fileAuthentication <- EML::eml$authentication(method = "MD5")
  fileAuthentication$authentication <- md5sum(fname)

  # construct physical
  spatialVectorPhysical <- EML::eml$physical(
    objectName = fname,
    authentication = fileAuthentication,
    size = fileSize,
    dataFormat = fileDataFormat,
    distribution = fileDistribution
  )


  # create spatialVector entity ---------------------------------------------

  newSV <- EML::eml$spatialVector(
    entityName = fname,
    entityDescription = description,
    physical = spatialVectorPhysical,
    coverage = spatialCoverage,
    attributeList = attr_list,
    geometricObjectCount = nrow(svname),
    id = fname)


  # add geometry type -------------------------------------------------------

  sfGeometry <- attr(svname$geometry, "class")[[1]]

  if (grepl("polygon", sfGeometry, ignore.case = TRUE)) {

    objectGeometry <- "Polygon"

  } else if (grepl("point", sfGeometry, ignore.case = TRUE)) {

    objectGeometry <- "Point"

  } else {

    stop("undetermined geometry")

  }

  newSV$geometry <- objectGeometry


  # add spatial reference  --------------------------------------------------

  epsg4326 <- EML::eml$spatialReference(
    horizCoordSysName = "GCS_WGS_1984"
  )

  newSV$spatialReference <- epsg4326

  # closing message ---------------------------------------------------------

  message("spatialVector created")

  # return spatial vector object --------------------------------------------

  return(newSV)

} # close create_spatialVector

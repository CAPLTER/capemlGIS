#' @title create_spatialVector
#'
#' @description create_spatialVector generates a EML entity of type
#'   spatialVector
#'
#' @details create_spatialVector creates a EML spatialVector object from a
#'   spatial data object (shapefile, kml) that is read into the R environment.
#'   The function reads the attributes and classes contained within a supporting
#'   csv file generated from the write_attributes function -
#'   create_spatialVector will look for a file in the working directory with a
#'   name of type spatialEntityName_attrs.csv. Because all attributes written to
#'   a kml (the output of create_spatialVector are of type character, factors
#'   are not considered in this workflow). Note that this functionality is
#'   predicated on the existence of a file containing metadata about the
#'   attributes, that that file is in the working directory, and that the file
#'   matches the name of the spatial data entity precisely. In addition to
#'   generating a EML entity of type spatialVector, create_spatialVector writes
#'   the spatial entity in the R environment to file as type kml. Unless
#'   projectNaming is set to false, the output file is renamed with the file
#'   with project id + base file name + file extension (kml in this case).
#'
#' @note create_spatialVector will look for a project id in the working
#'   environment; this parameter is not passed to the function and it must
#'   exist.
#' @note create_spatialVector currently accepts an argument for a base url path
#'   to which the new file name will be appended so as to be a web-resolvable
#'   file; the package defaults to a URL specific to the CAP LTER.
#' @note Because file name metadata is incorporated into the kml generated from
#'   the sf::st_write function, including the md5 hash of the object in the file
#'   name sensu other products generated by this package is not feasible for
#'   spatialVector objects.
#' @note All vector objects are transformed to epsg 4326 (WGS 1984)
#'
#' @param svname The unquoted name of the spatial data object in the R
#'   environment.
#' @param description A quoted description of the spatial object that will
#'   populate the entityDescription element of the EML document.
#' @param geoDescription A textual description of the geographic study area of
#'   the vector. "CAP LTER study area" is the default.
#' @param baseURL (optional) The base path of the web-accessible location of the
#'   data file; the name of the resulting file will be passed to the base path
#'   to generate a web-resolvable file path.
#' @param projectNaming Logical indicating if the raster file should be renamed
#'   per the style used by the CAP LTER (default) with the project id + base
#'   file name + md5sum + file extension. The passed file or directory name will
#'   be used if this parameter is set to FALSE.
#'
#' @import EML
#' @import dplyr
#' @import sf
#' @importFrom readr read_csv
#'
#' @return EML spatialVector object is returned. Additionally, the spatial data
#'   entity is written to file as type kml, and renamed with the project id +
#'   base file name + file extension (kml in this case).
#'
#' @examples
#' \dontrun{
#'
#' # read the vector using the sf package
#' NAIP_grid_map <- read_sf(dsn = 'NAIP_GRID.kml')
#'
#' # assign Name to the column that is the site identifier (Name in this
#' example); strip irrelevant or un-populated columns and remove geometry to
#' write # attribute table
#' NAIP_grid_map <- NAIP_grid_map %>%
#'   select(Name) %>%
#'   st_drop_geometry()
#'
#' # write the attributes to a csv template and add metadata - this file will be
#' # read when the EML object is build
#' write_attributes(NAIP_grid_map)
#'
#' # reimport kml to write spatial vector object
#'
#' colsToKeep <- read_sf(dsn = "NAIP_GRID.kml") %>%
#'   discard(~all(is.na(.x))) %>%
#'   map_df(~.x) %>%
#'   colnames()
#'
#' NAIP_grid_map <- read_sf(dsn = "NAIP_GRID.kml") %>%
#'   dplyr::select(one_of(colsToKeep))
#'
#' NAIP_grid_map_desc <- "NAIP NDVI data are presented as a series of tiles each
#' representing a portion of the overall central Arizona coverage area. The
#' relative position of tiles to the entire coverage area is detailed in this
#' file as a kml as well as the files NAIP_GRID.png and NAIP_GRID.pdf included
#' with this data set. Tiles are identified with a 20-digit signature (format:
#' xxxxxxxxxx-xxxxxxxxxx)."
#'
#' NAIP_grid_map_SV <- create_spatialVector(svname = NAIP_grid_map,
#'                                          description = NAIP_grid_map_desc,
#'                                          projectNaming = FALSE)
#'
#' # The resulting spatialVector entity can be added to a EML dataset
#' dataset <- EML::eml$dataset(spatialVector = NAIP_grid_map_SV)
#' }
#'
#' @export

create_spatialVector <- function(svname,
                                 description,
                                 geoDescription = "CAP LTER study area",
                                 baseURL = "https://data.gios.asu.edu/datasets/cap/",
                                 projectNaming = TRUE) {

  # required parameters -----------------------------------------------------

  # do not proceed if the project id has not been identified in the working env
  if (projectNaming == TRUE & !exists('projectid')) { stop("missing project id") }

  # do not proceed if a description is not provided
  if (missing('description')) { stop("please provide a description for this vector") }


  # object names ------------------------------------------------------------

  # add kml extension and project id to object name if projectNaming == TRUE
  namestr <- deparse(substitute(svname))

  if (projectNaming == TRUE) {
    fname <- paste0(projectid, "_", namestr, ".kml")
  } else {
    fname <- paste0(namestr, ".kml")
  }


  # ensure epsg4326 ---------------------------------------------------------
  svname <- st_transform(svname, crs = 4326)


  # geographic coverage -----------------------------------------------------

  vectorGeographicDescription <- geoDescription
  spatialCoverage <- EML::set_coverage(geographicDescription = vectorGeographicDescription,
                                       west = st_bbox(svname)[['xmin']],
                                       east = st_bbox(svname)[['xmax']],
                                       north = st_bbox(svname)[['ymax']],
                                       south = st_bbox(svname)[['ymin']])



  # write to kml ------------------------------------------------------------

  sf::st_write(obj = svname,
               dsn = fname,
               driver = 'kml',
               delete_layer = TRUE,
               delete_dsn = TRUE)


  # attributes --------------------------------------------------------------

  # read the attributes file and extract classes into its own vector then delete
  # from attrs data frame (as required by rEML), but note that column classes
  # must be of type 'ordered', 'numeric', 'character', 'factor' or 'Date' so
  # change spatial types to character
  attrs <- read_csv(paste0(namestr, "_attrs.csv")) %>%
    mutate(
      columnClasses = replace(columnClasses, grepl("polygon", columnClasses, ignore.case = T), "character")
    )
  classes <- attrs %>% pull(columnClasses) # column classes to vector (req'd by set_attributes)
  attrs <- attrs %>% dplyr::select(-columnClasses) # remove col classes from attrs (req'd by set_attributes)
  attr_list <- set_attributes(attributes = attrs, col_classes = classes)


  # set physical ------------------------------------------------------------

  spatialVectorPhysical <- EML::set_physical(objectName = fname,
                                             url = paste0(baseURL, fname))


  # create spatialVector entity ---------------------------------------------

  newSV <- EML::eml$spatialVector(
    entityName = fname,
    entityDescription = description,
    physical = spatialVectorPhysical,
    coverage = spatialCoverage,
    attributeList = attr_list,
    geometricObjectCount = nrow(svname),
    id = fname)


  # add geometry type -------------------------------------------------------

  sfGeometry <- attr(svname$geometry, "class")[[1]]

  if (grepl("polygon", sfGeometry, ignore.case = TRUE)) {

    objectGeometry <- "Polygon"

  } else if (grepl("point", sfGeometry, ignore.case = TRUE)) {

    objectGeometry <- "Point"

  } else {

    stop("undetermined geometry")
  }

  newSV$geometry <- objectGeometry


  # add spatial reference  --------------------------------------------------

  epsg4326 <- EML::eml$spatialReference(
    horizCoordSysName = 'GCS_WGS_1984'
  )

  newSV$spatialReference <- epsg4326


  # return spatial vector object --------------------------------------------

  return(newSV)


} # close create_spatialVector
